// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../selenium-webdriver
//   ../atma-utils

declare module 'selenium-query' {
    import { WebdriverQuery } from 'selenium-query/webdriver/WebdriverQuery';
    import { CookieContainer } from 'selenium-query/common/CookieContainer';
    class SQuery extends WebdriverQuery {
        static default: typeof SQuery;
        static CookieContainer: typeof CookieContainer;
    }
    export = SQuery;
}

declare module 'selenium-query/webdriver/WebdriverQuery' {
    import { IPseudoSelectorFn } from 'selenium-query/common/SelectorsEx'; 
     import { NetworkTracer } from 'selenium-query/fetch/NetworkTracer'; 
     import { NetworkResponse } from 'selenium-query/fetch/NetworkDriver'; 
     import { ILoadConfig } from 'selenium-query/common/IConfig'; 
     import { IQueryStatics } from 'selenium-query/common/IQueryStatics'; 
     import { WebDriver } from 'selenium-webdriver'; 
     import { IElement, IDriver, IDriverManager } from 'selenium-query/common/IDriver';
    import { Deferred } from 'selenium-query/types/Deferred';
    import { IQuery } from 'selenium-query/common/IQuery';
    import { IBuildConfig, ISettings } from 'selenium-query/common/IConfig';
    import { WebdriverFormData } from 'selenium-query/webdriver/WebdriverFormData';
    import { FormDataBase } from 'selenium-query/common/FormDataBase';
    export type WebdriverQuerySync = Omit<WebdriverQuery, 'then' | 'resolve' | 'reject' | 'done' | 'fail'>;
    export class WebdriverQuery extends IQuery<IElement, WebdriverQuery & {
            then: never;
    }> {
            protected hasClassFn(node: IElement, name: string): Deferred<boolean>;
            protected addClassFn(node: IElement, name: string): Deferred<void>;
            protected removeClassFn(node: IElement, name: string): Deferred<void>;
            protected toggleClassFn(node: IElement, name: string): Deferred<void>;
            protected textGetFn(node: IElement): Deferred<string>;
            protected textSetFn(node: IElement, text: string): Deferred<void>;
            protected htmlOuterGetFn(node: IElement): Deferred<string>;
            protected htmlGetFn(node: IElement): Deferred<string>;
            protected htmlSetFn(node: IElement, text: string): Deferred<void>;
            protected appendFn(node: IElement, html: string): Deferred<void>;
            protected prependFn(node: IElement, html: string): Deferred<void>;
            protected beforeFn(node: IElement, html: string): Deferred<void>;
            protected afterFn(node: IElement, html: string): Deferred<void>;
            protected cssGet(node: IElement, prop: string): Promise<any>;
            protected cssSet(node: IElement, css: {
                    [key: string]: any;
            }): Deferred<void>;
            protected heightGetFn(node: IElement): Promise<number>;
            protected widthGetFn(node: IElement): Promise<number>;
            protected innerHeightFn(node: IElement): Promise<number>;
            protected innerWidthFn(node: IElement): Promise<number>;
            protected getBoundingClientRect(node: IElement): Promise<{
                    top: number;
                    left: number;
                    width: number;
                    height: number;
            }>;
            protected getPosition(node: IElement): Promise<{
                    top: number;
                    left: number;
            }>;
            protected scrollTopGetFn(node: IElement): Promise<number>;
            protected scrollTopSetFn(node: IElement, scroll: number): Deferred<void>;
            protected scrollLeftGetFn(node: IElement): Promise<number>;
            protected scrollLeftSetFn(node: IElement, scroll: number): Deferred<void>;
            protected evalFn(node: IElement, mix: Function | string, ...args: any[]): Promise<any>;
            protected clickFn(node: IElement): Promise<void>;
            protected triggerFn(node: IElement, type: string, ...args: any[]): Promise<void>;
            protected selectFn(node: IElement, ...args: any[]): Promise<any>;
            protected focusFn(node: IElement): Promise<void>;
            protected blurFn(node: IElement): Promise<void>;
            protected sendKeysFn(node: IElement, mix: any): Promise<void>;
            protected typeFn(node: IElement, str: string): Promise<void>;
            protected pressFn(node: IElement, str: string): Promise<void>;
            protected removeFn(node: IElement): Promise<void>;
            protected attrGetFn(node: IElement, prop: string): Promise<any>;
            protected attrSetFn(node: IElement, attr: {
                    [key: string]: any;
            }): Deferred<void>;
            protected valGetFn(node: IElement): Promise<any>;
            protected valSetFn(node: IElement, value: any): Deferred<void>;
            protected dataGetFn(node: IElement, key: string): Promise<any>;
            protected dataSetFn(node: IElement, data: object): Deferred<void>;
            protected propGetFn(node: IElement, key: string): Promise<any>;
            protected propSetFn(node: IElement, data: object): Deferred<void>;
            protected findFn(node: IElement, selector: string): Deferred<IElement[]>;
            protected matchesFn(node: IElement, selector: string): Promise<boolean>;
            protected parentFn(node: IElement): Deferred<IElement>;
            protected closestFn(node: IElement, sel: string): Promise<IElement>;
            protected childrenFn(node: IElement, sel?: string): Promise<IElement[]>;
            protected nextFn(node: IElement, sel?: string): Promise<IElement>;
            protected getField<T>(node: IElement, field: string): Deferred<T>;
            protected setField(node: IElement, obj: any): Deferred<void>;
            protected setField(node: IElement, field: string, val: any): Deferred<void>;
            protected callField<T>(node: IElement, field: string, ...args: any[]): Deferred<T>;
            protected _onFn(node: IElement, type: string, cb: Function): Promise<any>;
            protected _offFn(node: IElement, type: string, cb?: Function): Promise<any>;
            protected _onOnceFn(node: IElement, type: string, cb: Function): Promise<any>;
            manage(): IDriverManager;
            waitForPageLoad(): IQuery<any>;
            waitForPageReady(): IQuery<any>;
            waitForElement(selector: string): IQuery<IElement>;
            waitForResource(selector: string): IQuery<IElement>;
            unlock(): void;
            getDriver(): WebDriver;
            createFormData(): Promise<WebdriverFormData>;
            static FormData: typeof FormDataBase;
            static build(config: IBuildConfig, setts?: ISettings): IQuery<any>;
            static load(url: string, config?: IBuildConfig, setts?: ISettings): IQuery<any, any> | WebdriverQuery;
            static loadWithWebdriver(url: string, config?: IBuildConfig, setts?: ISettings): WebdriverQuery;
            static fetch<T = any | WebdriverQuery>(url: string, config?: IBuildConfig, setts?: ISettings): Promise<{
                    status: number;
                    headers: {
                            [lowerCased: string]: string;
                    };
                    data: T;
            }>;
            static setDriver(driver: IDriver): void;
            static getDriver(config: IBuildConfig, setts?: ISettings): Promise<IDriver>;
            static unlockDriver(mix: any): void;
            static newAsync(mix?: any, parent?: IQuery<IElement>): WebdriverQuery;
            static cheerio: IQueryStatics<IQuery<any, any>>;
            static jsdom: IQueryStatics<IQuery<any, any>>;
            static network: {
                    isCached(url: string, config?: ILoadConfig): boolean;
                    isCachedAsync(url: string, config?: ILoadConfig): Promise<boolean>;
                    clearCookies(): void;
                    clearCached(url: string, config?: ILoadConfig): void;
                    load<T = any>(url: string, config?: ILoadConfig): Promise<NetworkResponse<T>>;
                    getCookies(url?: string): string;
                    setCookies(url: string, cookies: string | string[] | {
                            [key: string]: string;
                    }, opts: {
                            extend: boolean;
                    }): void;
                    tracer: NetworkTracer;
            };
            static pseudo: {
                    [key: string]: IPseudoSelectorFn<any> | {
                            isNodeFilter: boolean;
                            fn: <T = any>($: IQuery<T, any>, arg?: string) => IQuery<T, any> | Promise<IQuery<T, any>>;
                    };
            };
    }
}

declare module 'selenium-query/common/CookieContainer' {
    interface ICookie {
        key: string;
        value: string;
        rawOptions?: string;
    }
    class DomainCookies {
        domain: string;
        arr: ICookie[];
        constructor(domain: string);
        add(mix: string | string[] | {
            [key: string]: string;
        }, opts?: {
            extend: boolean;
        }): void;
        stringify(): string;
    }
    export class CookieContainer {
        domains: {
            [domain: string]: DomainCookies;
        };
        addCookies(cookies: string | string[] | {
            [key: string]: string;
        }): any;
        addCookies(url: string, cookies: string | string[] | {
            [key: string]: string;
        }): any;
        addCookies(url: string, cookies: string | string[] | {
            [key: string]: string;
        }, opts: {
            extend: boolean;
        }): any;
        clearCookies(): void;
        getCookies(url?: string): string;
    }
    export const cookieContainer: CookieContainer;
    export {};
}

declare module 'selenium-query/common/SelectorsEx' {
    import { IQuery } from 'selenium-query/common/IQuery';
    export interface IPseudoSelectorFn<TElement = any> {
        ($: IQuery<TElement>, arg: string): boolean | Promise<boolean>;
    }
    export namespace SelectorsEx {
        const pseudoFns: {
            [key: string]: IPseudoSelectorFn<any> | {
                isNodeFilter: boolean;
                fn: <T = any>($: IQuery<T>, arg?: string) => (IQuery<T> | Promise<IQuery<T>>);
            };
        };
        function register(name: string, fn: IPseudoSelectorFn): void;
        function find<TElement>(el: IQuery<TElement>, selector: string, find: (el: IQuery<TElement>, selector: string) => IQuery<TElement>): IQuery<any, any>;
    }
}

declare module 'selenium-query/fetch/NetworkTracer' {
    import { class_EventEmitter } from 'atma-utils';
    export class NetworkTracer extends class_EventEmitter {
        active: boolean;
        spans: NetworkSpan[];
        createSpan(req: IReq): NetworkSpan;
        onComplete(cb: (span: NetworkSpan) => void): void;
        clear(): void;
    }
    export class NetworkSpan extends class_EventEmitter {
        startTime: Date;
        endTime: Date;
        res: IRes;
        req: IReq;
        cached: boolean;
        constructor(req: IReq);
        complete(res: IRes): void;
    }
    interface IReq {
        method: string;
        url: string;
        headers: {
            [name: string]: string;
        };
        body: any;
    }
    interface IRes {
        url: string;
        status: number;
        headers: {
            [name: string]: string;
        };
        body: any;
    }
    export {};
}

declare module 'selenium-query/fetch/NetworkDriver' {
    import { ILoadConfig } from "selenium-query/common/IConfig";
    import { NetworkTracer } from 'selenium-query/fetch/NetworkTracer';
    export const NetworkDriver: {
        isCached(url: string, config?: ILoadConfig): boolean;
        isCachedAsync(url: string, config?: ILoadConfig): Promise<boolean>;
        clearCookies(): void;
        clearCached(url: string, config?: ILoadConfig): void;
        load<T = any>(url: string, config?: ILoadConfig): Promise<NetworkResponse<T>>;
        getCookies(url?: string): string;
        setCookies(url: string, cookies: string | string[] | {
            [key: string]: string;
        }, opts: {
            extend: boolean;
        }): void;
        tracer: NetworkTracer;
    };
    export interface NetworkResponse<T = any> {
        status: number;
        message?: string;
        headers: {
            [name: string]: string;
        };
        url: string;
        body: T;
    }
}

declare module 'selenium-query/common/IConfig' {
    import { IQuery } from "selenium-query/common/IQuery";
    import { CookieContainer } from 'selenium-query/common/CookieContainer';
    export interface IBuildConfig {
        name?: string;
        args?: string[];
        binaryPath?: string;
        applyOptions?(builder: any, options: any): any;
        setOptions?(builder: any, options: any): any;
        setArguments?(options: any): any;
        setBinaryPath?(options: any): any;
        setLogging?(options: any): any;
        headers?: {
            [name: string]: string;
        } | string;
        method?: 'post' | 'get' | 'delete' | 'patch' | 'head' | string;
        query?: {
            [name: string]: string;
        };
        body?: string | Buffer | any;
        cookies?: {
            [name: string]: string;
        } | string[] | string;
        cookiesDefault?: {
            [name: string]: string;
        } | string[] | string;
        cache?: boolean | {
            folder?: string;
            maxAge?: number | string;
            compress?: boolean;
        };
        cacheQueryIgnore?: string[];
        /** Webdriver will load this url, or requested url, to set the cookies first */
        cookieOrigin?: string;
        cookieContainer?: CookieContainer;
        [key: string]: any;
    }
    export interface ILoadConfig extends IBuildConfig {
        retryCount?: number;
        retryTimeout?: number;
        follow?: number;
        httpsProxy?: string | {
            url: string;
            username?: string;
            password?: string;
        };
        ignoreSSLErrors?: boolean;
        /** optional timeout in ms */
        timeoutMs?: number;
        doNotThrow?: boolean;
        /** default: true */
        includeDefaultHeaders?: boolean;
        /** default: true */
        includeCookies?: boolean;
    }
    export interface ISettings {
        pool?: boolean | number;
        query?: IQuery<any>;
        opts?: any;
    }
}

declare module 'selenium-query/common/IQueryStatics' {
    import { WebdriverQuery } from 'selenium-query/webdriver/WebdriverQuery';
    import { IBuildConfig, ISettings, ILoadConfig } from "selenium-query/common/IConfig";
    import { IQuery } from "selenium-query/common/IQuery";
    import { SelectorsEx } from 'selenium-query/common/SelectorsEx';
    export interface IQueryStatics<TQuery extends IQuery<any> = IQuery<any>> {
        fromHtml(html: string): TQuery;
        build(config: IBuildConfig, setts?: ISettings): TQuery;
        load(url: string, config: ILoadConfig, setts?: ISettings): TQuery;
        unlockDriver(mix: any): any;
        fetch<T = any | WebdriverQuery>(url: string, config?: ILoadConfig & {
            baseUrl?: string;
        }, setts?: ISettings): Promise<{
            status: number;
            headers: {
                [lowerCased: string]: string;
            };
            data: T;
        }>;
        pseudo: typeof SelectorsEx.pseudoFns;
        [key: string]: any;
    }
}

declare module 'selenium-query/common/IDriver' {
    import { WebDriver, WebElement } from 'selenium-webdriver';
    export type IDriver = WebDriver;
    export interface IDriverManager {
        addCookie(cookie: any): Promise<void>;
    }
    export interface IThenableDriver extends Promise<any>, IDriver {
    }
    export type IElement = WebElement;
}

declare module 'selenium-query/types/Deferred' {
    export interface Deferred<T> extends Promise<T> {
        done(cb: (x: T) => void | any): this;
        fail(cb: (error: Error) => void | any): this;
    }
}

declare module 'selenium-query/common/IQuery' {
    import { class_Dfr } from 'atma-utils';
    import { Deferred } from 'selenium-query/types/Deferred';
    export class IQueryCtx {
        owner: IQuery<any>;
        self: IQuery<any>;
        source: string;
        url: string;
        status: number;
        headers: {
            [key: string]: string;
        };
        thener: (resolve: any, reject: any) => IQuery<any>;
        Ctor: new (mix?: any) => IQuery<any>;
        newSync(arr?: any, parent?: IQuery<any>): IQuery<any, any>;
        newAsync(arr?: any, parent?: IQuery<any>): IQuery<any, any>;
        static copyFrom(targetCtx: IQueryCtx, parentCtx: IQueryCtx): IQueryCtx;
    }
    export type IQuerySync<TElement> = Omit<IQuery<TElement>, 'then' | 'resolve' | 'reject' | 'done' | 'fail'>;
    export type TSync<T extends PromiseLike<any>> = Omit<T, 'then' | 'resolve' | 'reject' | 'done' | 'fail'>;
    export abstract class IQuery<TElement = any, TContainer extends IQuery<TElement, any> & {
        then: never;
    } = any> extends class_Dfr<TContainer> implements PromiseLike<TContainer> {
        [index: number]: TElement;
        length: number;
        ctx: IQueryCtx;
        constructor(mix?: any);
        ensureSync(): IQuery<TElement>;
        ensureAsync(): IQuery<TElement>;
        resolve(...args: any[]): this;
        wait(ms: number): Promise<unknown>;
        hasClass(name: string): PromiseLike<boolean>;
        protected abstract hasClassFn(node: TElement, name: string): Deferred<boolean>;
        addClass(name: string): IQuery<any, any>;
        protected abstract addClassFn(node: TElement, name: string): Deferred<void>;
        removeClass(name: string): IQuery<TElement>;
        protected abstract removeClassFn(node: TElement, name: string): Deferred<void>;
        toggleClass(name: string): IQuery<TElement>;
        protected abstract toggleClassFn(node: TElement, name: string): Deferred<void>;
        add(mix: any): any;
        eq(index: number): IQuery<any, any>;
        get(index: number): TElement;
        slice(start?: number, end?: number): IQuery<any, any>;
        each(fn: (node: TElement, i?: number) => void | TElement | any): IQuery<any, any>;
        map(fn: (node: TElement, i?: number) => void | TElement | any): IQuery<any, any>;
        toArray(): Promise<unknown>;
        as<T>(): T;
        use<TCtor extends new (...args: any[]) => IQuery<any>>(Ctor: TCtor): InstanceType<TCtor>;
        text(): PromiseLike<string>;
        text(str: string): IQuery<TElement>;
        protected abstract textGetFn(node: TElement): Deferred<string>;
        protected abstract textSetFn(node: TElement, text: string): Deferred<void>;
        html(): PromiseLike<string>;
        html(str: string): IQuery<TElement>;
        outerHtml(): PromiseLike<string>;
        protected abstract htmlGetFn(node: TElement): Deferred<string>;
        protected abstract htmlOuterGetFn(node: TElement): Deferred<string>;
        protected abstract htmlSetFn(node: TElement, text: string): Deferred<void>;
        append(html: string): IQuery<TElement>;
        protected abstract appendFn(node: TElement, html: string): Deferred<void>;
        prepend(html: string): IQuery<any, any>;
        protected abstract prependFn(node: TElement, html: string): Deferred<void>;
        before(html: string): IQuery<any, any>;
        protected abstract beforeFn(node: TElement, html: string): Deferred<void>;
        after(html: string): IQuery<any, any>;
        protected abstract afterFn(node: TElement, html: string): Deferred<void>;
        css(cssObj: {
            [key: string]: any;
        }): IQuery<TElement>;
        css(key: string, val: any): IQuery<TElement>;
        css(key: string): Promise<any>;
        protected abstract cssGet(node: TElement, prop: string): Promise<any>;
        protected abstract cssSet(node: TElement, css: {
            [key: string]: any;
        }): Deferred<void>;
        height(): Promise<number>;
        height(val: any): IQuery<TElement>;
        protected abstract heightGetFn(node: TElement): Promise<number>;
        innerHeight(): PromiseLike<number>;
        protected abstract innerHeightFn(node: TElement): Promise<number>;
        width(): Promise<number>;
        width(val: any): IQuery<TElement>;
        protected abstract widthGetFn(node: TElement): Promise<number>;
        innerWidth(): PromiseLike<number>;
        protected abstract innerWidthFn(node: TElement): Promise<number>;
        offset(): Promise<{
            top: number;
            left: number;
        }>;
        protected abstract getBoundingClientRect(node: TElement): Promise<{
            top: number;
            left: number;
            width: number;
            height: number;
        }>;
        position(): Promise<{
            top: number;
            left: number;
        }>;
        protected abstract getPosition(node: TElement): Promise<{
            top: number;
            left: number;
        }>;
        scrollTop(): Promise<number>;
        scrollTop(scroll: number): IQuery<TElement>;
        protected abstract scrollTopGetFn(node: TElement): Promise<number>;
        protected abstract scrollTopSetFn(node: TElement, scroll: number): Deferred<void>;
        scrollLeft(): Promise<number>;
        scrollLeft(scroll: number): IQuery<TElement>;
        protected abstract scrollLeftGetFn(node: TElement): Promise<number>;
        protected abstract scrollLeftSetFn(node: TElement, scroll: number): Deferred<void>;
        eval(mix: Function | string, ...args: any[]): Promise<any>;
        protected abstract evalFn(node: TElement, mix: Function | string, ...args: any[]): Promise<any>;
        click(): IQuery<TElement>;
        protected abstract clickFn(node: TElement): Promise<void>;
        trigger(type: any, ...args: any[]): IQuery<TElement>;
        protected abstract triggerFn(node: TElement, type: string, ...args: any[]): Promise<void>;
        select(...args: any[]): IQuery<TElement>;
        protected abstract selectFn(node: TElement, ...args: any[]): Promise<void>;
        focus(): IQuery<TElement>;
        protected abstract focusFn(node: TElement): Promise<void>;
        blur(): IQuery<TElement>;
        protected abstract blurFn(node: TElement): Promise<void>;
        sendKeys(mix: any): IQuery<TElement>;
        protected abstract sendKeysFn(node: TElement, mix: any): Promise<void>;
        type(str: any): IQuery<TElement>;
        protected abstract typeFn(node: TElement, str: string): Promise<void>;
        press(str: any): IQuery<TElement>;
        protected abstract pressFn(node: TElement, str: string): Promise<void>;
        remove(): IQuery<TElement>;
        protected abstract removeFn(node: TElement): Promise<void>;
        attr(name: string): Promise<any>;
        attr(vals: {
            [key: string]: any;
        }): IQuery<TElement>;
        attr(key: string, val: any): IQuery<TElement>;
        protected abstract attrGetFn(node: TElement, prop: string): Promise<any>;
        protected abstract attrSetFn(node: TElement, attr: {
            [key: string]: any;
        }): Deferred<void>;
        val(): PromiseLike<any>;
        val(val: any): IQuery<TElement>;
        protected abstract valGetFn(node: TElement): Promise<any>;
        protected abstract valSetFn(node: TElement, value: any): Deferred<void>;
        data(key: string): PromiseLike<any>;
        data(key: string, val: any): IQuery<TElement>;
        data(dataObj: {
            [key: string]: any;
        }): IQuery<TElement>;
        protected abstract dataGetFn(node: TElement, key: string): Promise<any>;
        protected abstract dataSetFn(node: TElement, data: object): Deferred<void>;
        prop(key: string): PromiseLike<any>;
        prop(key: string, val: any): IQuery<TElement>;
        prop(obj: {
            [key: string]: any;
        }): IQuery<TElement>;
        protected abstract propGetFn(node: TElement, key: string): Promise<any>;
        protected abstract propSetFn(node: TElement, data: object): Deferred<void>;
        find(sel: string): IQuery<TElement>;
        protected abstract findFn(node: TElement, selector: string): Deferred<TElement[]>;
        filter(fn: (node: TElement) => boolean | Promise<boolean>): IQuery<TElement>;
        filter(sel: string): IQuery<TElement>;
        protected abstract matchesFn(node: TElement, selector: string): Promise<boolean>;
        parent(): IQuery<TElement>;
        protected abstract parentFn(node: TElement): Promise<TElement>;
        closest(sel: string): IQuery<TElement>;
        protected abstract closestFn(node: TElement, sel: string): Promise<TElement>;
        children(sel?: string): IQuery<TElement>;
        protected abstract childrenFn(node: TElement, sel?: string): Promise<TElement[]>;
        next(sel?: string): IQuery<TElement>;
        protected abstract nextFn(node: TElement, sel?: string): Promise<TElement>;
        protected abstract getField<T>(node: TElement, field: string): Deferred<T>;
        protected abstract setField(node: TElement, obj: any): Deferred<void>;
        protected abstract setField(node: TElement, field: string, val: any): Deferred<void>;
        protected abstract callField<T>(node: TElement, field: string, ...args: any[]): Deferred<T>;
        on(type: string, cb: (el: TElement) => void): IQuery<any, any>;
        off(type: string, cb: Function): IQuery<any, any>;
        once(type: string, cb?: (event: any) => void): IQuery<any, any>;
        protected abstract _onFn(node: TElement, type: string, cb: Function): Promise<any>;
        protected abstract _onOnceFn(node: TElement, type: string, cb: Function): Promise<any>;
        protected abstract _offFn(node: TElement, type: string, cb: Function): Promise<any>;
    }
}

declare module 'selenium-query/webdriver/WebdriverFormData' {
    import { IElement } from 'selenium-query/common/IDriver';
    import { IQuery } from 'selenium-query/common/IQuery';
    type TFormDataFile = {
        file: string;
    };
    export class WebdriverFormData {
        $: IQuery;
        form: IElement;
        formId: string;
        protected constructor($: IQuery, form: IElement, formId: string);
        append(name: string, value: string | number | TFormDataFile): Promise<this>;
        static create($: IQuery): Promise<WebdriverFormData>;
    }
    export {};
}

declare module 'selenium-query/common/FormDataBase' {
    export class FormDataBase {
        dict: any;
        append(key: any, value: any): this;
        entries(): [string, any][];
    }
}

