// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../selenium-webdriver
//   ../atma-utils
//   ../node-fetch

declare module 'selenium-query' {
    import { WebdriverQuery } from 'selenium-query/webdriver/WebdriverQuery';
    import { CookieContainer } from 'selenium-query/common/CookieContainer';
    import { BrowserNetworkInterceptor } from 'selenium-query/webdriver/network/BrowserNetworkInterceptor';
    import { BrowserNetworkMonitor } from 'selenium-query/webdriver/network/BrowserNetworkMonitor';
    class SQuery extends WebdriverQuery {
        static default: typeof SQuery;
        static CookieContainer: typeof CookieContainer;
        static BrowserNetworkInterceptor: typeof BrowserNetworkInterceptor;
        static BrowserNetworkMonitor: typeof BrowserNetworkMonitor;
    }
    export = SQuery;
}

declare module 'selenium-query/webdriver/WebdriverQuery' {
    import { IPseudoSelectorFn } from 'selenium-query/common/SelectorsEx'; 
     import { NetworkTracer } from 'selenium-query/fetch/NetworkTracer'; 
     import { NetworkResponse } from 'selenium-query/fetch/NetworkDriver'; 
     import { IQueryStatics } from 'selenium-query/common/IQueryStatics'; 
     import { WebDriver } from 'selenium-webdriver'; 
     import { IElement, IDriver, IDriverManager } from 'selenium-query/common/IDriver';
    import { Deferred } from 'selenium-query/types/Deferred';
    import { IQuery, IQueryConditionFn, IQueryWaitOptions } from 'selenium-query/common/IQuery';
    import { IWebdriverBuildConfig } from 'selenium-query/webdriver/Webdriver';
    import { IBuildConfig, ILoadConfig, ISettings } from 'selenium-query/common/IConfig';
    import { IJsdomBuildConfig } from 'selenium-query/jsdom/JsdomDriver';
    import { ICheerioBuildConfig } from 'selenium-query/cheerio/CheerioDriver';
    import { WebdriverFormData } from 'selenium-query/webdriver/WebdriverFormData';
    import { FormDataBase } from 'selenium-query/common/FormDataBase';
    import { type WebElement } from 'selenium-webdriver';
    import { JsdomQuery } from 'selenium-query/jsdom/JsdomQuery';
    import { CherrioQuery } from 'selenium-query/cheerio/CherrioQuery';
    export type WebdriverQuerySync = Omit<WebdriverQuery, 'then' | 'resolve' | 'reject' | 'done' | 'fail'>;
    export class WebdriverQuery extends IQuery<IElement, WebdriverQuery & {
            then: never;
    }> {
            protected hasClassFn(node: IElement, name: string): Deferred<boolean>;
            protected addClassFn(node: IElement, name: string): Deferred<void>;
            protected removeClassFn(node: IElement, name: string): Deferred<void>;
            protected toggleClassFn(node: IElement, name: string): Deferred<void>;
            protected textGetFn(node: IElement): Deferred<string>;
            protected textSetFn(node: IElement, text: string): Deferred<void>;
            protected htmlOuterGetFn(node: IElement): Deferred<string>;
            protected htmlGetFn(node: IElement): Deferred<string>;
            protected htmlSetFn(node: IElement, text: string): Deferred<void>;
            protected appendFn(node: IElement, html: string): Deferred<void>;
            protected prependFn(node: IElement, html: string): Deferred<void>;
            protected beforeFn(node: IElement, html: string): Deferred<void>;
            protected afterFn(node: IElement, html: string): Deferred<void>;
            protected cssGet(node: IElement, prop: string): Promise<any>;
            protected cssSet(node: IElement, css: {
                    [key: string]: any;
            }): Deferred<void>;
            protected heightGetFn(node: IElement): Promise<number>;
            protected widthGetFn(node: IElement): Promise<number>;
            protected innerHeightFn(node: IElement): Promise<number>;
            protected innerWidthFn(node: IElement): Promise<number>;
            protected getBoundingClientRect(node: IElement): Promise<{
                    top: number;
                    left: number;
                    width: number;
                    height: number;
            }>;
            protected getPosition(node: IElement): Promise<{
                    top: number;
                    left: number;
            }>;
            protected scrollTopGetFn(node: IElement): Promise<number>;
            protected scrollTopSetFn(node: IElement, scroll: number): Deferred<void>;
            protected scrollLeftGetFn(node: IElement): Promise<number>;
            protected scrollLeftSetFn(node: IElement, scroll: number): Deferred<void>;
            protected evalFn(node: IElement, mix: Function | string, ...args: any[]): Promise<any>;
            protected clickFn(node: IElement): Promise<void>;
            protected triggerFn(node: IElement, type: string, ...args: any[]): Promise<void>;
            protected selectFn(node: IElement, ...args: any[]): Promise<any>;
            protected focusFn(node: IElement): Promise<void>;
            protected blurFn(node: IElement): Promise<void>;
            protected sendKeysFn(node: IElement, mix: any): Promise<void>;
            protected typeFn(node: IElement, str: string): Promise<void>;
            protected pressFn(node: IElement, str: string): Promise<void>;
            protected removeFn(node: IElement): Promise<void>;
            protected attrGetFn(node: IElement, prop: string): Promise<any>;
            protected attrSetFn(node: IElement, attr: {
                    [key: string]: any;
            }): Deferred<void>;
            protected valGetFn(node: IElement): Promise<any>;
            protected valSetFn(node: IElement, value: any): Deferred<void>;
            protected dataGetFn(node: IElement, key: string): Promise<any>;
            protected dataSetFn(node: IElement, data: object): Deferred<void>;
            protected propGetFn(node: IElement, key: string): Promise<any>;
            protected propSetFn(node: IElement, data: object): Deferred<void>;
            protected findFn(node: IElement, selector: string): Deferred<IElement[]>;
            protected matchesFn(node: IElement, selector: string): Promise<boolean>;
            protected parentFn(node: IElement): Deferred<IElement>;
            protected closestFn(node: IElement, sel: string): Promise<IElement>;
            protected childrenFn(node: IElement, sel?: string): Promise<IElement[]>;
            protected nextFn(node: IElement, sel?: string): Promise<IElement>;
            protected getField<T>(node: IElement, field: string): Deferred<T>;
            protected setField(node: IElement, obj: any): Deferred<void>;
            protected setField(node: IElement, field: string, val: any): Deferred<void>;
            protected callField<T>(node: IElement, field: string, ...args: any[]): Deferred<T>;
            protected _onFn(node: IElement, type: string, cb: Function): Promise<any>;
            protected _offFn(node: IElement, type: string, cb?: Function): Promise<any>;
            protected _onOnceFn(node: IElement, type: string, cb: Function): Promise<any>;
            manage(): IDriverManager;
            waitForPageLoad(urlPattern?: string | RegExp): IQuery<any>;
            waitForPageReady(urlPattern?: string | RegExp): IQuery<any>;
            waitForElement(selector: string, opts?: IQueryWaitOptions<WebElement>): IQuery<IElement>;
            waitForElement(selector: string, check?: IQueryConditionFn<WebElement>): IQuery<IElement>;
            waitForNoElement(selector: string, opts?: IQueryWaitOptions<WebElement>): IQuery<IElement>;
            waitForNoElement(selector: string, check?: IQueryConditionFn<WebElement>): IQuery<IElement>;
            waitForResource(selector: string): IQuery<IElement>;
            unlock(): void;
            getDriver(): WebDriver;
            createFormData(): Promise<WebdriverFormData>;
            static FormData: typeof FormDataBase;
            static build(config: IBuildConfig, setts?: ISettings): IQuery<any>;
            static load(url: string, config: IJsdomBuildConfig, setts?: ISettings): JsdomQuery;
            static load(url: string, config: ICheerioBuildConfig, setts?: ISettings): CherrioQuery;
            static load(url: string, config?: IWebdriverBuildConfig, setts?: ISettings): WebdriverQuery;
            static fetch<T = any | WebdriverQuery>(url: string, config?: ILoadConfig & {
                    baseUrl?: string;
            }, setts?: ISettings): Promise<{
                    status: number;
                    headers: {
                            [lowerCased: string]: string;
                    };
                    data: T;
            }>;
            static setDriver(driver: IDriver): void;
            static getDriver(config: IBuildConfig, setts?: ISettings): Promise<IDriver>;
            static unlockDriver(mix: any): void;
            static newAsync(mix?: any, parent?: IQuery<IElement>): WebdriverQuery;
            static cheerio: IQueryStatics<IQuery<any, any>>;
            static jsdom: IQueryStatics<IQuery<any, any>>;
            static network: {
                    isCached(url: string, config?: ILoadConfig & {
                            fetcher?: any;
                    }): boolean;
                    isCachedAsync(url: string, config?: ILoadConfig & {
                            fetcher?: any;
                    }): Promise<boolean>;
                    clearCookies(): void;
                    clearCached(url: string, config?: ILoadConfig & {
                            fetcher?: any;
                    }): void;
                    load<T = any>(url: string, config?: ILoadConfig & {
                            fetcher?: any;
                    }): Promise<NetworkResponse<T>>;
                    getCookies(url?: string): string;
                    setCookies(url: string, cookies: string | string[] | {
                            [key: string]: string;
                    }, opts: {
                            extend: boolean;
                    }): void;
                    tracer: NetworkTracer;
            };
            static pseudo: {
                    [key: string]: IPseudoSelectorFn<any> | {
                            isNodeFilter: boolean;
                            fn: <T = any>($: IQuery<T, any>, arg?: string) => IQuery<T, any> | Promise<IQuery<T, any>>;
                    };
            };
    }
}

declare module 'selenium-query/common/CookieContainer' {
    interface ICookie {
        key: string;
        value: string;
        rawOptions?: string;
    }
    class DomainCookies {
        domain: string;
        arr: ICookie[];
        constructor(domain: string);
        add(mix: string | string[] | {
            [key: string]: string;
        }, opts?: {
            extend: boolean;
        }): void;
        stringify(): string;
    }
    export class CookieContainer {
        domains: {
            [domain: string]: DomainCookies;
        };
        addCookies(cookies: string | string[] | {
            [key: string]: string;
        }): any;
        addCookies(url: string, cookies: string | string[] | {
            [key: string]: string;
        }): any;
        addCookies(url: string, cookies: string | string[] | {
            [key: string]: string;
        }, opts: {
            extend: boolean;
        }): any;
        clearCookies(): void;
        getCookies(url?: string): string;
    }
    export const cookieContainer: CookieContainer;
    export {};
}

declare module 'selenium-query/webdriver/network/BrowserNetworkInterceptor' {
    export class BrowserNetworkInterceptor {
        wsConnection: any;
        devToolsConnection: any;
        static start(driver: any): Promise<BrowserNetworkInterceptor>;
        constructor(wsConnection: any, devToolsConnection: any);
        interceptions: {
            urlMatch: RegExp;
            response: {
                status?: number;
                headers?: Record<string, string>;
                body: string | any;
            };
        }[];
        register(params: {
            match: RegExp;
            response: BrowserNetworkInterceptor['interceptions'][0]['response'];
        }): void;
    }
}

declare module 'selenium-query/webdriver/network/BrowserNetworkMonitor' {
    import { class_EventEmitter } from 'atma-utils';
    import { WebDriver } from 'selenium-webdriver';
    export interface INetworkMonitorRequest {
        requestId: string;
        request: {
            url: string;
            method: string;
            headers: Record<string, string>;
            date: number;
        };
        response: {
            status: number;
            headers: Record<string, string>;
            date: number;
        };
    }
    interface IBrowserNetworkMonitorEvents {
        requestWillBeSent(req: INetworkMonitorRequest): any;
        loadingFinished(req: INetworkMonitorRequest): any;
        responseReceived(req: INetworkMonitorRequest): any;
    }
    type TRequestFilter = (req: INetworkMonitorRequest['request']) => boolean;
    export class BrowserNetworkMonitor extends class_EventEmitter<IBrowserNetworkMonitorEvents> {
        static start(driver: WebDriver & {
            createCDPConnection?: any;
            _wsConnection?: WebSocket;
        }): Promise<BrowserNetworkMonitor>;
        constructor(driver: any, wsConnection: any);
        getRequest(regexp?: RegExp): INetworkMonitorRequest;
        getRequest(filter?: TRequestFilter): INetworkMonitorRequest;
        getRequest(mix?: RegExp | TRequestFilter): INetworkMonitorRequest;
        getRequests(regexp?: RegExp): INetworkMonitorRequest[];
        getRequests(filter?: TRequestFilter): INetworkMonitorRequest[];
        getRequests(mix?: RegExp | TRequestFilter): INetworkMonitorRequest[];
        getResponseBody(req: INetworkMonitorRequest): Promise<{
            base64Encoded: any;
            body: any;
        }>;
        getRequestBody(req: INetworkMonitorRequest): Promise<{
            body: any;
        }>;
    }
    export {};
}

declare module 'selenium-query/common/SelectorsEx' {
    import { IQuery } from 'selenium-query/common/IQuery';
    export interface IPseudoSelectorFn<TElement = any> {
        ($: IQuery<TElement>, arg: string): boolean | Promise<boolean>;
    }
    export namespace SelectorsEx {
        const pseudoFns: {
            [key: string]: IPseudoSelectorFn<any> | {
                isNodeFilter: boolean;
                fn: <T = any>($: IQuery<T>, arg?: string) => (IQuery<T> | Promise<IQuery<T>>);
            };
        };
        function register(name: string, fn: IPseudoSelectorFn): void;
        function find<TElement>(el: IQuery<TElement>, selector: string, find: (el: IQuery<TElement>, selector: string) => IQuery<TElement>): IQuery<any, any>;
    }
}

declare module 'selenium-query/fetch/NetworkTracer' {
    import { class_EventEmitter } from 'atma-utils';
    export class NetworkTracer extends class_EventEmitter {
        active: boolean;
        spans: NetworkSpan[];
        createSpan(req: IReq): NetworkSpan;
        onComplete(cb: (span: NetworkSpan) => void): void;
        clear(): void;
    }
    export class NetworkSpan extends class_EventEmitter {
        startTime: Date;
        endTime: Date;
        res: IRes;
        req: IReq;
        cached: boolean;
        constructor(req: IReq);
        complete(res: IRes): void;
    }
    interface IReq {
        method: string;
        url: string;
        headers: {
            [name: string]: string;
        };
        body: any;
    }
    interface IRes {
        url: string;
        status: number;
        headers: {
            [name: string]: string;
        };
        body: any;
    }
    export {};
}

declare module 'selenium-query/fetch/NetworkDriver' {
    import fetch from 'node-fetch';
    import { ILoadConfig } from "selenium-query/common/IConfig";
    import { NetworkTracer } from 'selenium-query/fetch/NetworkTracer';
    type INetworkDriverLoadConfig = ILoadConfig & {
        fetcher?: typeof fetch;
    };
    export const NetworkDriver: {
        isCached(url: string, config?: INetworkDriverLoadConfig): boolean;
        isCachedAsync(url: string, config?: INetworkDriverLoadConfig): Promise<boolean>;
        clearCookies(): void;
        clearCached(url: string, config?: INetworkDriverLoadConfig): void;
        load<T = any>(url: string, config?: INetworkDriverLoadConfig): Promise<NetworkResponse<T>>;
        getCookies(url?: string): string;
        setCookies(url: string, cookies: string | string[] | {
            [key: string]: string;
        }, opts: {
            extend: boolean;
        }): void;
        tracer: NetworkTracer;
    };
    export interface NetworkResponse<T = any> {
        status: number;
        message?: string;
        headers: {
            [name: string]: string;
        };
        url: string;
        body: T;
    }
    export {};
}

declare module 'selenium-query/common/IQueryStatics' {
    import { WebdriverQuery } from 'selenium-query/webdriver/WebdriverQuery';
    import { IBuildConfig, ISettings, ILoadConfig } from "selenium-query/common/IConfig";
    import { IQuery } from "selenium-query/common/IQuery";
    import { SelectorsEx } from 'selenium-query/common/SelectorsEx';
    export interface IQueryStatics<TQuery extends IQuery<any> = IQuery<any>> {
        fromHtml(html: string): TQuery;
        build(config: IBuildConfig, setts?: ISettings): TQuery;
        load(url: string, config: ILoadConfig, setts?: ISettings): TQuery;
        unlockDriver(mix: any): any;
        fetch<T = any | WebdriverQuery>(url: string, config?: ILoadConfig & {
            baseUrl?: string;
        }, setts?: ISettings): Promise<{
            status: number;
            headers: {
                [lowerCased: string]: string;
            };
            data: T;
        }>;
        pseudo: typeof SelectorsEx.pseudoFns;
        [key: string]: any;
    }
}

declare module 'selenium-query/common/IDriver' {
    import { WebDriver, WebElement } from 'selenium-webdriver';
    export type IDriver = WebDriver;
    export interface IDriverManager {
        addCookie(cookie: any): Promise<void>;
    }
    export interface IThenableDriver extends Promise<any>, IDriver {
    }
    export type IElement = WebElement;
}

declare module 'selenium-query/types/Deferred' {
    export interface Deferred<T> extends Promise<T> {
        done(cb: (x: T) => void | any): this;
        fail(cb: (error: Error) => void | any): this;
    }
}

declare module 'selenium-query/common/IQuery' {
    import { class_Dfr } from 'atma-utils';
    import { Deferred } from 'selenium-query/types/Deferred';
    export class IQueryCtx {
        owner: IQuery<any>;
        self: IQuery<any>;
        source: string;
        url: string;
        status: number;
        headers: {
            [key: string]: string;
        };
        breadcrumbs: string[];
        thener: (resolve: any, reject: any) => IQuery<any>;
        Ctor: new (mix?: any) => IQuery<any>;
        newSync(arr?: any, parent?: IQuery<any>): IQuery<any, any>;
        newAsync(arr?: any, parent?: IQuery<any>): IQuery<any, any>;
        static copyFrom(targetCtx: IQueryCtx, parentCtx: IQueryCtx): IQueryCtx;
    }
    export type IQuerySync<TElement> = Omit<IQuery<TElement>, 'then' | 'resolve' | 'reject' | 'done' | 'fail'>;
    export type TSync<T extends PromiseLike<any>> = Omit<T, 'then' | 'resolve' | 'reject' | 'done' | 'fail'>;
    export abstract class IQuery<TElement = any, TContainer extends IQuery<TElement, any> & {
        then: never;
    } = any> extends class_Dfr<TContainer> implements PromiseLike<TContainer> {
        [index: number]: TElement;
        length: number;
        ctx: IQueryCtx;
        constructor(mix?: any);
        get [Symbol.toStringTag](): string;
        ensureSync(): IQuery<TElement>;
        ensureAsync(): IQuery<TElement>;
        resolve(...args: any[]): this;
        wait(ms: number): IQuery<any, any>;
        require(opts?: {
            count?: number;
        }): IQuery<any, any>;
        hasClass(name: string): PromiseLike<boolean>;
        protected abstract hasClassFn(node: TElement, name: string): Deferred<boolean>;
        addClass(name: string): IQuery<any, any>;
        protected abstract addClassFn(node: TElement, name: string): Deferred<void>;
        removeClass(name: string): IQuery<TElement>;
        protected abstract removeClassFn(node: TElement, name: string): Deferred<void>;
        toggleClass(name: string): IQuery<TElement>;
        protected abstract toggleClassFn(node: TElement, name: string): Deferred<void>;
        add(mix: any): any;
        eq(index: number): IQuery<any, any>;
        get(index: number): TElement;
        slice(start?: number, end?: number): IQuery<any, any>;
        each(fn: (node: TElement, i?: number) => void | TElement | any): IQuery<any, any>;
        map<TResult>(fn: (node: IQuery<TElement>, i?: number) => TResult): IQuery<TResult extends PromiseLike<any> ? Awaited<TResult> : TResult, any>;
        toArray(): Promise<TElement[]>;
        as<T>(): T;
        use<TCtor extends new (...args: any[]) => IQuery<any>>(Ctor: TCtor): InstanceType<TCtor>;
        text(): PromiseLike<string>;
        text(str: string): IQuery<TElement>;
        protected abstract textGetFn(node: TElement): Deferred<string>;
        protected abstract textSetFn(node: TElement, text: string): Deferred<void>;
        html(): PromiseLike<string>;
        html(str: string): IQuery<TElement>;
        outerHtml(): PromiseLike<string>;
        protected abstract htmlGetFn(node: TElement): Deferred<string>;
        protected abstract htmlOuterGetFn(node: TElement): Deferred<string>;
        protected abstract htmlSetFn(node: TElement, text: string): Deferred<void>;
        append(html: string): IQuery<TElement>;
        protected abstract appendFn(node: TElement, html: string): Deferred<void>;
        prepend(html: string): IQuery<any, any>;
        protected abstract prependFn(node: TElement, html: string): Deferred<void>;
        before(html: string): IQuery<any, any>;
        protected abstract beforeFn(node: TElement, html: string): Deferred<void>;
        after(html: string): IQuery<any, any>;
        protected abstract afterFn(node: TElement, html: string): Deferred<void>;
        css(cssObj: {
            [key: string]: any;
        }): IQuery<TElement>;
        css(key: string, val: any): IQuery<TElement>;
        css(key: string): Promise<any>;
        protected abstract cssGet(node: TElement, prop: string): Promise<any>;
        protected abstract cssSet(node: TElement, css: {
            [key: string]: any;
        }): Deferred<void>;
        height(): Promise<number>;
        height(val: any): IQuery<TElement>;
        protected abstract heightGetFn(node: TElement): Promise<number>;
        innerHeight(): PromiseLike<number>;
        protected abstract innerHeightFn(node: TElement): Promise<number>;
        width(): Promise<number>;
        width(val: any): IQuery<TElement>;
        protected abstract widthGetFn(node: TElement): Promise<number>;
        innerWidth(): PromiseLike<number>;
        protected abstract innerWidthFn(node: TElement): Promise<number>;
        offset(): Promise<{
            top: number;
            left: number;
        }>;
        protected abstract getBoundingClientRect(node: TElement): Promise<{
            top: number;
            left: number;
            width: number;
            height: number;
        }>;
        position(): Promise<{
            top: number;
            left: number;
        }>;
        protected abstract getPosition(node: TElement): Promise<{
            top: number;
            left: number;
        }>;
        scrollTop(): Promise<number>;
        scrollTop(scroll: number): IQuery<TElement>;
        protected abstract scrollTopGetFn(node: TElement): Promise<number>;
        protected abstract scrollTopSetFn(node: TElement, scroll: number): Deferred<void>;
        scrollLeft(): Promise<number>;
        scrollLeft(scroll: number): IQuery<TElement>;
        protected abstract scrollLeftGetFn(node: TElement): Promise<number>;
        protected abstract scrollLeftSetFn(node: TElement, scroll: number): Deferred<void>;
        eval(mix: Function | string, ...args: any[]): Promise<any>;
        protected abstract evalFn(node: TElement, mix: Function | string, ...args: any[]): Promise<any>;
        click(): IQuery<TElement>;
        protected abstract clickFn(node: TElement): Promise<void>;
        trigger(type: any, ...args: any[]): IQuery<TElement>;
        protected abstract triggerFn(node: TElement, type: string, ...args: any[]): Promise<void>;
        select(...args: any[]): IQuery<TElement>;
        protected abstract selectFn(node: TElement, ...args: any[]): Promise<void>;
        focus(): IQuery<TElement>;
        protected abstract focusFn(node: TElement): Promise<void>;
        blur(): IQuery<TElement>;
        protected abstract blurFn(node: TElement): Promise<void>;
        sendKeys(mix: string): IQuery<TElement>;
        protected abstract sendKeysFn(node: TElement, mix: any): Promise<void>;
        type(str: string): IQuery<TElement>;
        protected abstract typeFn(node: TElement, str: string): Promise<void>;
        press(str: string): IQuery<TElement>;
        protected abstract pressFn(node: TElement, str: string): Promise<void>;
        remove(): IQuery<TElement>;
        protected abstract removeFn(node: TElement): Promise<void>;
        attr(name: string): Promise<any>;
        attr(vals: {
            [key: string]: any;
        }): IQuery<TElement>;
        attr(key: string, val: any): IQuery<TElement>;
        protected abstract attrGetFn(node: TElement, prop: string): Promise<any>;
        protected abstract attrSetFn(node: TElement, attr: {
            [key: string]: any;
        }): Deferred<void>;
        val(): PromiseLike<any>;
        val(val: any): IQuery<TElement>;
        protected abstract valGetFn(node: TElement): Promise<any>;
        protected abstract valSetFn(node: TElement, value: any): Deferred<void>;
        data(key: string): PromiseLike<string>;
        data(key: string, val: any): IQuery<TElement>;
        data(dataObj: {
            [key: string]: any;
        }): IQuery<TElement>;
        protected abstract dataGetFn(node: TElement, key: string): Promise<any>;
        protected abstract dataSetFn(node: TElement, data: object): Deferred<void>;
        prop(key: string): PromiseLike<any>;
        prop(key: string, val: any): IQuery<TElement>;
        prop(obj: {
            [key: string]: any;
        }): IQuery<TElement>;
        protected abstract propGetFn(node: TElement, key: string): Promise<any>;
        protected abstract propSetFn(node: TElement, data: object): Deferred<void>;
        find(sel: string): IQuery<TElement>;
        protected abstract findFn(node: TElement, selector: string): Deferred<TElement[]>;
        filter(fn: (node: TElement) => boolean | Promise<boolean>): IQuery<TElement>;
        filter(sel: string): IQuery<TElement>;
        protected abstract matchesFn(node: TElement, selector: string): Promise<boolean>;
        parent(): IQuery<TElement>;
        protected abstract parentFn(node: TElement): Promise<TElement>;
        closest(sel: string): IQuery<TElement>;
        protected abstract closestFn(node: TElement, sel: string): Promise<TElement>;
        children(sel?: string): IQuery<TElement>;
        protected abstract childrenFn(node: TElement, sel?: string): Promise<TElement[]>;
        next(sel?: string): IQuery<TElement>;
        protected abstract nextFn(node: TElement, sel?: string): Promise<TElement>;
        protected abstract getField<T>(node: TElement, field: string): Deferred<T>;
        protected abstract setField(node: TElement, obj: any): Deferred<void>;
        protected abstract setField(node: TElement, field: string, val: any): Deferred<void>;
        protected abstract callField<T>(node: TElement, field: string, ...args: any[]): Deferred<T>;
        on(type: string, cb: (el: TElement) => void): IQuery<any, any>;
        off(type: string, cb: Function): IQuery<any, any>;
        once(type: string, cb?: (event: any) => void): IQuery<any, any>;
        protected abstract _onFn(node: TElement, type: string, cb: Function): Promise<any>;
        protected abstract _onOnceFn(node: TElement, type: string, cb: Function): Promise<any>;
        protected abstract _offFn(node: TElement, type: string, cb: Function): Promise<any>;
        abstract waitForElement(selector: string, mix?: IQueryWaitOptions<TElement> | IQueryConditionFn<TElement>): IQuery<TElement>;
    }
    export interface IQueryConditionFn<T> {
        ($: IQuery<T>): Promise<boolean>;
    }
    export interface IQueryWaitOptions<T> {
        hidden?: boolean;
        visible?: boolean;
        check?: IQueryConditionFn<T>;
        interval?: number;
        timeout?: number;
        /** execute any other code while waiting. */
        tick?: () => Promise<any>;
    }
}

declare module 'selenium-query/webdriver/Webdriver' {
    import { IBuildConfig } from "selenium-query/common/IConfig";
    import { WebdriverQuery } from "selenium-query/webdriver/WebdriverQuery";
    import { IQueryStatics } from "selenium-query/common/IQueryStatics";
    import { type WebDriver } from 'selenium-webdriver';
    export interface IWebdriverBuildConfig extends IBuildConfig {
        name?: 'Chrome' | 'Firefox' | 'Edge' | string;
        driver?: WebDriver;
    }
    export const Webdriver: IQueryStatics<WebdriverQuery>;
}

declare module 'selenium-query/common/IConfig' {
    import type { WebDriver } from 'selenium-webdriver';
    import { IQuery } from "selenium-query/common/IQuery";
    import { CookieContainer } from 'selenium-query/common/CookieContainer';
    export interface IBuildConfig {
        args?: string[];
        binaryPath?: string;
        applyOptions?(builder: any, options: any): any;
        setOptions?(builder: any, options: any): any;
        setArguments?(options: any): any;
        setBinaryPath?(options: any): any;
        setLogging?(options: any): any;
        /** Configurate driver before page is loaded. You can set e.g. the chrome dev tools commands: https://chromedevtools.github.io/devtools-protocol/ */
        setDriverConfiguration?(driver: WebDriver): Promise<any>;
        headers?: {
            [name: string]: string;
        } | string;
        method?: 'post' | 'get' | 'delete' | 'patch' | 'head' | string;
        query?: {
            [name: string]: string;
        };
        body?: string | Buffer | any;
        cookies?: {
            [name: string]: string;
        } | string[] | string;
        cookiesDefault?: {
            [name: string]: string;
        } | string[] | string;
        cache?: boolean | {
            folder?: string;
            maxAge?: number | string;
            compress?: boolean;
        };
        cacheQueryIgnore?: string[];
        /** Webdriver will load this url, or requested url, to set the cookies first */
        cookieOrigin?: string;
        cookieContainer?: CookieContainer;
        [key: string]: any;
    }
    export interface ILoadConfig extends IBuildConfig {
        retryCount?: number;
        retryTimeout?: number;
        follow?: number;
        httpsProxy?: string | {
            url: string;
            username?: string;
            password?: string;
        };
        ignoreSSLErrors?: boolean;
        /** optional timeout in ms */
        timeoutMs?: number;
        doNotThrow?: boolean;
        /** default: true */
        includeDefaultHeaders?: boolean;
        /** default: true */
        includeCookies?: boolean;
    }
    export interface ISettings {
        pool?: boolean | number;
        query?: IQuery<any>;
        opts?: {
            deserialize?: boolean;
            [key: string]: any;
        };
    }
}

declare module 'selenium-query/jsdom/JsdomDriver' {
    import { IQueryStatics } from 'selenium-query/common/IQueryStatics';
    import { IBuildConfig } from "selenium-query/common/IConfig";
    export interface IJsdomBuildConfig extends IBuildConfig {
        name: 'jsdom';
        html?: string;
        fragment?: boolean;
    }
    export const JsdomDriver: IQueryStatics;
}

declare module 'selenium-query/cheerio/CheerioDriver' {
    import { IQueryStatics } from 'selenium-query/common/IQueryStatics';
    import { IBuildConfig } from "selenium-query/common/IConfig";
    export interface ICheerioBuildConfig extends IBuildConfig {
        name: 'cheerio';
        html: string;
    }
    export const CheerioDriver: IQueryStatics;
}

declare module 'selenium-query/webdriver/WebdriverFormData' {
    import { IElement } from 'selenium-query/common/IDriver';
    import { IQuery } from 'selenium-query/common/IQuery';
    type TFormDataFile = {
        file: string;
    };
    export class WebdriverFormData {
        $: IQuery;
        form: IElement;
        formId: string;
        protected constructor($: IQuery, form: IElement, formId: string);
        append(name: string, value: string | number | TFormDataFile): Promise<this>;
        static create($: IQuery): Promise<WebdriverFormData>;
    }
    export {};
}

declare module 'selenium-query/common/FormDataBase' {
    export class FormDataBase {
        dict: any;
        append(key: string, value: string | number | {
            file: string;
        }): this;
        entries(): [string, any][];
    }
}

declare module 'selenium-query/jsdom/JsdomQuery' {
    import { IQuery, IQueryConditionFn } from 'selenium-query/common/IQuery';
    import { IBuildConfig, ISettings } from 'selenium-query/common/IConfig';
    import { IDriver } from 'selenium-query/common/IDriver';
    import { Deferred } from 'selenium-query/types/Deferred';
    export class JsdomQuery extends IQuery<Element> {
        waitForElement(selector: string, mix?: {
            visible?: boolean;
            check?: IQueryConditionFn<Element>;
        } | IQueryConditionFn<Element>): IQuery<Element, any>;
        protected _onFn(node: Element, type: string, cb: Function): Promise<any>;
        protected _onOnceFn(node: Element, type: string, cb: Function): Promise<any>;
        protected _offFn(node: Element, type: string, cb: Function): Promise<any>;
        hasClassFn(node: Element, name: string): Deferred<boolean>;
        addClassFn(node: Element, name: string): Deferred<void>;
        removeClassFn(node: Element, name: string): Deferred<void>;
        toggleClassFn(node: Element, name: string): Deferred<void>;
        textGetFn(node: Element): Deferred<string>;
        textSetFn(node: Element, text: string): Deferred<void>;
        htmlOuterGetFn(node: Element): Deferred<string>;
        htmlGetFn(node: Element): Deferred<string>;
        htmlSetFn(node: Element, text: string): Deferred<void>;
        appendFn(node: Element, html: string): Deferred<void>;
        prependFn(node: Element, html: string): Deferred<void>;
        beforeFn(node: Element, html: string): Deferred<void>;
        afterFn(node: Element, html: string): Deferred<void>;
        cssGet(node: HTMLElement, prop: string): Promise<any>;
        cssSet(node: HTMLElement, css: {
            [key: string]: any;
        }): Deferred<void>;
        heightGetFn(node: HTMLElement): Promise<number>;
        widthGetFn(node: HTMLElement): Promise<number>;
        innerHeightFn(node: Element): Promise<number>;
        innerWidthFn(node: Element): Promise<number>;
        getBoundingClientRect(node: HTMLElement): Promise<{
            top: number;
            left: number;
            width: number;
            height: number;
        }>;
        getPosition(node: Element): Promise<{
            top: number;
            left: number;
        }>;
        scrollTopGetFn(node: Element): Promise<number>;
        scrollTopSetFn(node: Element, scroll: number): Deferred<void>;
        scrollLeftGetFn(node: Element): Promise<number>;
        scrollLeftSetFn(node: Element, scroll: number): Deferred<void>;
        evalFn(node: Element, mix: Function | string, ...args: any[]): Promise<any>;
        clickFn(node: HTMLElement): Promise<void>;
        triggerFn(node: HTMLElement, type: string, ...args: any[]): Promise<void>;
        selectFn(node: Element, ...args: any[]): Promise<any>;
        focusFn(node: Element): Promise<void>;
        blurFn(node: Element): Promise<void>;
        sendKeysFn(node: Element, mix: any): Promise<void>;
        typeFn(node: Element, str: string): Promise<void>;
        pressFn(node: Element, str: string): Promise<void>;
        removeFn(node: HTMLElement): Promise<void>;
        attrGetFn(node: HTMLElement, prop: string): Promise<any>;
        attrSetFn(node: Element, attr: {
            [key: string]: any;
        }): Deferred<void>;
        valGetFn(node: Element): Promise<any>;
        valSetFn(node: Element, value: any): Deferred<void>;
        dataGetFn(node: HTMLElement, key: string): Promise<any>;
        dataSetFn(node: HTMLElement, data: object): Deferred<void>;
        protected propGetFn(node: HTMLElement, key: string): Promise<any>;
        protected propSetFn(node: Element, data: object): Deferred<void>;
        findFn(node: Element, selector: string): Deferred<Element[]>;
        matchesFn(node: Element, selector: string): Deferred<boolean>;
        parentFn(node: Element): Promise<Element>;
        closestFn(node: Element, sel: string): Promise<Element>;
        childrenFn(node: Element, sel?: string): Promise<Element[]>;
        nextFn(node: Element, sel?: string): Promise<Element>;
        protected getField<T>(node: Element, field: string): Deferred<T>;
        protected setField(node: Element, obj: any): Deferred<void>;
        protected setField(node: Element, field: string, val: any): Deferred<void>;
        protected callField<T>(node: Element, field: string, ...args: any[]): Deferred<T>;
        static newAsync(mix?: any, parent?: IQuery<Element>): JsdomQuery;
        unlock(): void;
        static build(config: IBuildConfig, setts?: ISettings): Promise<IDriver>;
        static load(url: string, config: IBuildConfig, setts?: ISettings): JsdomQuery;
        static fetch(url: string, config?: IBuildConfig, setts?: ISettings): JsdomQuery;
        static setDriver(driver: IDriver): void;
        static getDriver(config: IBuildConfig, setts?: ISettings): Promise<IDriver>;
        static unlockDriver(mix: any): void;
    }
}

declare module 'selenium-query/cheerio/CherrioQuery' {
    import { IQuery, IQueryConditionFn } from 'selenium-query/common/IQuery';
    import { IBuildConfig, ISettings } from 'selenium-query/common/IConfig';
    import { IDriver } from 'selenium-query/common/IDriver';
    import { Deferred } from 'selenium-query/types/Deferred';
    export class CherrioQuery extends IQuery<CheerioElement> {
        waitForElement(selector: string, mix?: {
            visible?: boolean;
            check?: IQueryConditionFn<CheerioElement>;
        } | IQueryConditionFn<CheerioElement>): IQuery<CheerioElement, any>;
        protected _onFn(node: CheerioElement, type: string, cb: Function): Promise<any>;
        protected _onOnceFn(node: CheerioElement, type: string, cb: Function): Promise<any>;
        protected _offFn(node: CheerioElement, type: string, cb: Function): Promise<any>;
        hasClassFn(node: CheerioElement, name: string): Deferred<boolean>;
        addClassFn(node: CheerioElement, name: string): Deferred<void>;
        removeClassFn(node: CheerioElement, name: string): Deferred<void>;
        toggleClassFn(node: CheerioElement, name: string): Deferred<void>;
        textGetFn(node: CheerioElement): Deferred<string>;
        textSetFn(node: CheerioElement, text: string): Deferred<void>;
        htmlOuterGetFn(node: CheerioElement): Deferred<string>;
        htmlGetFn(node: CheerioElement): Deferred<string>;
        htmlSetFn(node: CheerioElement, text: string): Deferred<void>;
        appendFn(node: CheerioElement, html: string): Deferred<void>;
        prependFn(node: CheerioElement, html: string): Deferred<void>;
        beforeFn(node: CheerioElement, html: string): Deferred<void>;
        afterFn(node: CheerioElement, html: string): Deferred<void>;
        cssGet(node: CheerioElement, prop: string): Promise<any>;
        cssSet(node: CheerioElement, css: {
            [key: string]: any;
        }): Deferred<void>;
        heightGetFn(node: CheerioElement): Promise<number>;
        widthGetFn(node: CheerioElement): Promise<number>;
        innerHeightFn(node: CheerioElement): Promise<number>;
        innerWidthFn(node: CheerioElement): Promise<number>;
        getBoundingClientRect(node: CheerioElement): Promise<{
            top: number;
            left: number;
            width: number;
            height: number;
        }>;
        getPosition(node: CheerioElement): Promise<{
            top: number;
            left: number;
        }>;
        scrollTopGetFn(node: CheerioElement): Promise<number>;
        scrollTopSetFn(node: CheerioElement, scroll: number): Deferred<void>;
        scrollLeftGetFn(node: CheerioElement): Promise<number>;
        scrollLeftSetFn(node: CheerioElement, scroll: number): Deferred<void>;
        evalFn(node: CheerioElement, mix: Function | string, ...args: any[]): Promise<any>;
        clickFn(node: CheerioElement): Promise<void>;
        triggerFn(node: CheerioElement, type: string, ...args: any[]): Promise<void>;
        selectFn(node: CheerioElement, ...args: any[]): Promise<any>;
        focusFn(node: CheerioElement): Promise<void>;
        blurFn(node: CheerioElement): Promise<void>;
        sendKeysFn(node: CheerioElement, mix: any): Promise<void>;
        typeFn(node: CheerioElement, str: string): Promise<void>;
        pressFn(node: CheerioElement, str: string): Promise<void>;
        removeFn(node: CheerioElement): Promise<void>;
        attrGetFn(node: CheerioElement, prop: string): Promise<any>;
        attrSetFn(node: CheerioElement, attr: {
            [key: string]: any;
        }): Deferred<void>;
        valGetFn(node: CheerioElement): Promise<any>;
        valSetFn(node: CheerioElement, value: any): Deferred<void>;
        dataGetFn(node: CheerioElement, key: string): Promise<any>;
        dataSetFn(node: CheerioElement, data: object): Deferred<void>;
        protected propGetFn(node: CheerioElement, key: string): Promise<any>;
        protected propSetFn(node: CheerioElement, data: object): Deferred<void>;
        findFn(node: CheerioElement, selector: string): Deferred<CheerioElement[]>;
        matchesFn(node: CheerioElement, selector: string): Deferred<boolean>;
        parentFn(node: CheerioElement): Promise<CheerioElement>;
        closestFn(node: CheerioElement, sel: string): Promise<CheerioElement>;
        childrenFn(node: CheerioElement, sel?: string): Promise<CheerioElement[]>;
        nextFn(node: CheerioElement, sel?: string): Promise<CheerioElement>;
        protected getField<T>(node: CheerioElement, field: string): Deferred<T>;
        protected setField(node: CheerioElement, obj: any): Deferred<void>;
        protected setField(node: CheerioElement, field: string, val: any): Deferred<void>;
        protected callField<T>(node: CheerioElement, field: string, ...args: any[]): Deferred<T>;
        static newAsync(mix?: any, parent?: IQuery<CheerioElement>): CherrioQuery;
        unlock(): void;
        static build(config: IBuildConfig, setts?: ISettings): Promise<IDriver>;
        static load(url: string, config: IBuildConfig, setts?: ISettings): CherrioQuery;
        static fetch(url: string, config?: IBuildConfig, setts?: ISettings): CherrioQuery;
        static setDriver(driver: IDriver): void;
        static getDriver(config: IBuildConfig, setts?: ISettings): Promise<IDriver>;
        static unlockDriver(mix: any): void;
    }
}

